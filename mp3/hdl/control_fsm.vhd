-- VHDL Entity ece411.Control.interface
--
-- Created:
--          by - buris2.ews (gelib-057-34.ews.illinois.edu)
--          at - 22:03:41 02/13/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

ENTITY Control IS
   PORT( 
      CheckN     : IN     std_logic;
      CheckP     : IN     std_logic;
      CheckZ     : IN     std_logic;
      IR11       : IN     std_logic;
      MRESP_H    : IN     std_logic;
      Opcode     : IN     LC3b_opcode;
      RESET_L    : IN     std_logic;
      SHFop      : IN     lc3b_shftop;
      START_H    : IN     std_logic;
      clk        : IN     std_logic;
      m_align    : IN     std_logic;
      n          : IN     std_logic;
      p          : IN     std_logic;
      z          : IN     std_logic;
      ALUMuxSel  : OUT    lc3b_4mux_sel;
      ALUop      : OUT    LC3b_aluop;
      B_op       : OUT    std_logic;
      DestMuxSel : OUT    std_logic;
      LoadIR     : OUT    std_logic;
      LoadMAR    : OUT    std_logic;
      LoadMDR    : OUT    std_logic;
      LoadNZP    : OUT    std_logic;
      LoadPC     : OUT    std_logic;
      MARMuxSel  : OUT    lc3b_4mux_sel;
      MDRMuxSel  : OUT    std_logic;
      MREAD_L    : OUT    std_logic;
      MWRITEH_L  : OUT    std_logic;
      MWRITEL_L  : OUT    std_logic;
      PCMuxSel   : OUT    lc3b_8mux_sel;
      RFMuxSel   : OUT    lc3b_4mux_sel;
      RegWrite   : OUT    std_logic;
      StoreSR    : OUT    std_logic
   );

-- Declarations

END Control ;

--
-- VHDL Architecture ece411.Control.fsm
--
-- Created:
--          by - buris2.ews (gelib-057-34.ews.illinois.edu)
--          at - 22:03:42 02/13/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;
 
ARCHITECTURE fsm OF Control IS

   TYPE STATE_TYPE IS (
      Reset,
      BR1,
      Decode,
      BR2,
      ADD,
      L_AND,
      L_NOT,
      IF1,
      IF2,
      CalcADDR,
      IF3,
      ST1,
      ST2,
      LD1,
      LD2,
      JMP_RET,
      LEA,
      R7_PC,
      JSR,
      JSRR,
      TRAP1,
      TRAP2,
      TRAP3,
      TRAP4,
      I1,
      I2,
      Calc_B_addr,
      LDB1,
      STB0a,
      STB1a,
      STB0b,
      STB1b,
      LDB2,
      SHF_SRA,
      SHF_ENTRY,
      SHF_SRL,
      SHF_SLL,
      calc_align
   );
 
   -- Declare current and next state signals
   SIGNAL current_state : STATE_TYPE;
   SIGNAL next_state : STATE_TYPE;

BEGIN

   -----------------------------------------------------------------
   clocked_proc : PROCESS ( 
      clk,
      RESET_L
   )
   -----------------------------------------------------------------
   BEGIN
      IF (RESET_L = '0') THEN
         current_state <= Reset;
      ELSIF (clk'EVENT AND clk = '1') THEN
         current_state <= next_state;
      END IF;
   END PROCESS clocked_proc;
 
   -----------------------------------------------------------------
   nextstate_proc : PROCESS ( 
      CheckN,
      CheckP,
      CheckZ,
      IR11,
      MRESP_H,
      Opcode,
      SHFop,
      START_H,
      current_state,
      m_align,
      n,
      p,
      z
   )
   -----------------------------------------------------------------
   BEGIN
      CASE current_state IS
         WHEN Reset => 
            IF (START_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= Reset;
            END IF;
         WHEN BR1 => 
            IF (((n AND CheckN) OR
                (p AND CheckP) OR
                (z AND CheckZ)) = '1') THEN 
               next_state <= BR2;
            ELSE
               next_state <= IF1;
            END IF;
         WHEN Decode => 
            IF (Opcode = op_br) THEN 
               next_state <= BR1;
            ELSIF ((Opcode = op_ldr) OR 
                   (Opcode = op_str) OR
                   (Opcode = op_ldi) OR
                   (Opcode = op_sti)) THEN 
               next_state <= CalcADDR;
            ELSIF (Opcode = op_not) THEN 
               next_state <= L_NOT;
            ELSIF (Opcode = op_and) THEN 
               next_state <= L_AND;
            ELSIF (Opcode = op_add) THEN 
               next_state <= ADD;
            ELSIF (opcode = op_jmp) THEN 
               next_state <= JMP_RET;
            ELSIF (Opcode = op_lea) THEN 
               next_state <= LEA;
            ELSIF (opcode = op_trap) THEN 
               next_state <= TRAP1;
            ELSIF (opcode = op_jsr) THEN 
               next_state <= R7_PC;
            ELSIF ((Opcode = op_ldb) OR
                   (Opcode = op_stb)) THEN 
               next_state <= Calc_B_addr;
            ELSIF (Opcode = op_shf) THEN 
               next_state <= SHF_ENTRY;
            ELSE
               next_state <= IF1;
            END IF;
         WHEN BR2 => 
            next_state <= IF1;
         WHEN ADD => 
            next_state <= IF1;
         WHEN L_AND => 
            next_state <= IF1;
         WHEN L_NOT => 
            next_state <= IF1;
         WHEN IF1 => 
            next_state <= IF2;
         WHEN IF2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF3;
            ELSE
               next_state <= IF2;
            END IF;
         WHEN CalcADDR => 
            IF (Opcode = op_str) THEN 
               next_state <= ST1;
            ELSIF (Opcode = op_ldr) THEN 
               next_state <= LD1;
            ELSIF ((Opcode = op_sti) OR
                   (Opcode = op_ldi)) THEN 
               next_state <= I1;
            ELSE
               next_state <= CalcADDR;
            END IF;
         WHEN IF3 => 
            next_state <= Decode;
         WHEN ST1 => 
            next_state <= ST2;
         WHEN ST2 => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= ST2;
            END IF;
         WHEN LD1 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LD2;
            ELSE
               next_state <= LD1;
            END IF;
         WHEN LD2 => 
            next_state <= IF1;
         WHEN JMP_RET => 
            next_state <= IF1;
         WHEN LEA => 
            next_state <= IF1;
         WHEN R7_PC => 
            IF (IR11 = '1') THEN 
               next_state <= JSR;
            ELSIF (IR11 = '0') THEN 
               next_state <= JSRR;
            ELSE
               next_state <= R7_PC;
            END IF;
         WHEN JSR => 
            next_state <= IF1;
         WHEN JSRR => 
            next_state <= IF1;
         WHEN TRAP1 => 
            next_state <= TRAP2;
         WHEN TRAP2 => 
            next_state <= TRAP3;
         WHEN TRAP3 => 
            IF (MRESP_H = '1') THEN 
               next_state <= TRAP4;
            ELSE
               next_state <= TRAP3;
            END IF;
         WHEN TRAP4 => 
            next_state <= IF1;
         WHEN I1 => 
            IF (MRESP_H = '1') THEN 
               next_state <= I2;
            ELSE
               next_state <= I1;
            END IF;
         WHEN I2 => 
            IF (Opcode = op_sti) THEN 
               next_state <= ST1;
            ELSIF (Opcode = op_ldi) THEN 
               next_state <= LD1;
            ELSE
               next_state <= I2;
            END IF;
         WHEN Calc_B_addr => 
            IF (Opcode = op_ldb) THEN 
               next_state <= LDB1;
            ELSIF (Opcode = op_stb) THEN 
               next_state <= calc_align;
            ELSE
               next_state <= Calc_B_addr;
            END IF;
         WHEN LDB1 => 
            IF (MRESP_H = '1') THEN 
               next_state <= LDB2;
            ELSE
               next_state <= LDB1;
            END IF;
         WHEN STB0a => 
            next_state <= STB0b;
         WHEN STB1a => 
            next_state <= STB1b;
         WHEN STB0b => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STB0b;
            END IF;
         WHEN STB1b => 
            IF (MRESP_H = '1') THEN 
               next_state <= IF1;
            ELSE
               next_state <= STB1b;
            END IF;
         WHEN LDB2 => 
            next_state <= IF1;
         WHEN SHF_SRA => 
            next_state <= IF1;
         WHEN SHF_ENTRY => 
            IF (SHFop(0) = '0') THEN 
               next_state <= SHF_SLL;
            ELSIF (SHFop = "01") THEN 
               next_state <= SHF_SRL;
            ELSIF (SHFop = "11") THEN 
               next_state <= SHF_SRA;
            ELSE
               next_state <= SHF_ENTRY;
            END IF;
         WHEN SHF_SRL => 
            next_state <= IF1;
         WHEN SHF_SLL => 
            next_state <= IF1;
         WHEN calc_align => 
            IF ((m_align = '1')) THEN 
               next_state <= STB1a;
            ELSIF ((m_align = '0')) THEN 
               next_state <= STB0a;
            ELSE
               next_state <= calc_align;
            END IF;
         WHEN OTHERS =>
            next_state <= Reset;
      END CASE;
   END PROCESS nextstate_proc;
 
   -----------------------------------------------------------------
   output_proc : PROCESS ( 
      current_state
   )
   -----------------------------------------------------------------
   BEGIN
      -- Default Assignment
      ALUMuxSel <= "00";
      ALUop <= "000";
      B_op <= '0';
      DestMuxSel <= '0';
      LoadIR <= '0';
      LoadMAR <= '0';
      LoadMDR <= '0';
      LoadNZP <= '0';
      LoadPC <= '0';
      MARMuxSel <= "00";
      MDRMuxSel <= '0';
      MREAD_L <= '1';
      MWRITEH_L <= '1';
      MWRITEL_L <= '1';
      PCMuxSel <= "000";
      RFMuxSel <= "00";
      RegWrite <= '0';
      StoreSR <= '1';

      -- Combined Actions
      CASE current_state IS
         WHEN BR2 => 
            PCMuxSel <= "001";
            LoadPC <= '1' ;
         WHEN ADD => 
            ALUop <= alu_add;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "01";
         WHEN L_AND => 
            ALUop <= alu_and;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "01";
         WHEN L_NOT => 
            ALuop <= alu_not;
            RegWrite <= '1';
            LoadNZP <= '1';
            RFMuxSel <= "01";
         WHEN IF1 => 
            LoadMAR <= '1';
            LoadPC <= '1';
         WHEN IF2 => 
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN CalcADDR => 
            --MAR <- BaseR + (SEXT(offset6) << 1)
            ALUMuxSel <= "01";
            ALUop <= alu_add;
            MARMuxSel <= "01";
            LoadMAR <= '1';
         WHEN IF3 => 
            LoadIR <= '1';
         WHEN ST1 => 
            --MDR <- SR
            StoreSR <= '0';
            ALUop <= alu_pass;
            LoadMDR <= '1';
            MDRMuxSel <= '1';
         WHEN ST2 => 
            --M[MAR] <- MDR
            MWRITEL_L <= '0' after 6 ns;
            MWRITEH_L <= '0' after 6 ns;
         WHEN LD1 => 
            --MDR <- M[MAR]
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN LD2 => 
            -- DR <- MDR; setCC
            RegWrite <= '1';
            LoadNZP <= '1';
         WHEN JMP_RET => 
            LoadPC <= '1';
            PCMuxSel <= "010";
         WHEN LEA => 
            RegWrite <= '1';
            RFMuxSel <= "10";
            LoadNZP <= '1';
         WHEN R7_PC => 
            --R7 <- PC
            RegWrite <= '1';
            DestMuxSel <= '1';
            RFMuxSel <= "11";
         WHEN JSR => 
            LoadPC <= '1';
            PCMuxSel <= "011";
         WHEN JSRR => 
            LoadPC <= '1';
            PCMuxSel <= "010";
         WHEN TRAP1 => 
            --R7 <- PC
            RegWrite <= '1';
            DestMuxSel <= '1';
            RFMuxSel <= "11";
         WHEN TRAP2 => 
            --MAR <- ZEXT(trapvect8) << 1
            LoadMAR <= '1';
            MARMuxSel <= "10";
         WHEN TRAP3 => 
            --MDR <- M[MAR]
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN TRAP4 => 
            --PC <- MDR
            LoadPC <= '1';
            PCMuxSel <= "100";
         WHEN I1 => 
            --MDR <- M[MAR]
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN I2 => 
            --MAR <- MDR
            --MAR <- M[BaseR + SEXT(offset6)<<1]
            LoadMAR <= '1';
            MARMuxSel <= "11";
         WHEN Calc_B_addr => 
            --MAR <- BaseR + SEXT(offset6)
            LoadMAR <= '1';
            MARMuxsel <= "01";
            ALUop <= alu_add;
            ALUMuxsel <= "10";
         WHEN LDB1 => 
            --MDR <- M[MAR]
            LoadMDR <= '1';
            MREAD_L <= '0' after 6 ns;
         WHEN STB0a => 
            --mem addr is word aligned
            --MDR <- SR
            MDRMuxsel <= '1';
            LoadMDR <= '1';
            ALUop <= alu_pass;
            StoreSR <= '0';
         WHEN STB1a => 
            --memm addr NOT word aligned
            --MDR <- SR<<8
            MDRMuxsel <= '1';
            LoadMDR <= '1';
            StoreSR <= '0';
            ALUop <= alu_sll;
            ALUMuxsel <= "11";
         WHEN STB0b => 
            --M[MAR] <- MDR[7:0]
            MWRITEL_L <= '0' after 6 ns;
         WHEN STB1b => 
            --M[MAR] <- MDR[15:8]
            MWRITEH_L <= '0' after 6 ns;
         WHEN LDB2 => 
            --DR <- M[MAR]
            --ZEXTing handled in byteSelect block
            --m_align is pulled from MAR from Calc_B_addr state
            RegWrite <= '1';
            B_op <= '1';
            LoadNZP <= '1';
         WHEN SHF_SRA => 
            RegWrite <= '1';
            RFMuxsel <= "01";
            LoadNZP <= '1';
            ALUMuxsel <= "10";
            ALUop <= alu_sra;
         WHEN SHF_ENTRY => 
            ALUMuxsel <= "10";
         WHEN SHF_SRL => 
            RegWrite <= '1';
            RFMuxsel <= "01";
            LoadNZP <= '1';
            ALUMuxsel <= "10";
            ALUop <= alu_srl;
         WHEN SHF_SLL => 
            RegWrite <= '1';
            RFMuxsel <= "01";
            LoadNZP <= '1';
            ALUMuxsel <= "10";
            ALUop <= alu_sll;
         WHEN OTHERS =>
            NULL;
      END CASE;
   END PROCESS output_proc;
 
END fsm;
