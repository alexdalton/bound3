-- VHDL Entity ece411.Cache_Datapath.interface
--
-- Created:
--          by - buris2.ews (evrt-252-10.ews.illinois.edu)
--          at - 15:10:18 02/28/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;

ENTITY Cache_Datapath IS
   PORT( 
      ADDRESS     : IN     LC3b_word;
      CACHE_WRITE : IN     std_logic;
      DATAOUT     : IN     LC3b_word;
      MREAD_L     : IN     std_logic;
      MRESP_EN    : IN     std_logic;
      MWRITEH_L   : IN     std_logic;
      MWRITEL_L   : IN     std_logic;
      PMADDRsel   : IN     std_logic;
      PMDATAIN    : IN     LC3B_OWORD;
      RESET_L     : IN     std_logic;
      WRstate     : IN     std_logic;
      clk         : IN     std_logic;
      set_dirty   : IN     std_logic;
      ACTIVE      : OUT    std_logic;
      CACHE_HIT   : OUT    std_logic;
      DATAIN      : OUT    LC3b_word;
      DIRTY       : OUT    std_logic;
      MRESP_H     : OUT    std_logic;
      PMADDRESS   : OUT    LC3B_WORD;
      PMDATAOUT   : OUT    LC3B_OWORD;
      WRITING     : OUT    std_logic
   );

-- Declarations

END Cache_Datapath ;

--
-- VHDL Architecture ece411.Cache_Datapath.struct
--
-- Created:
--          by - buris2.ews (evrt-252-10.ews.illinois.edu)
--          at - 15:10:18 02/28/14
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2012.1 (Build 6)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.NUMERIC_STD.all;

LIBRARY ece411;
USE ece411.LC3b_types.all;


ARCHITECTURE struct OF Cache_Datapath IS

   -- Architecture declarations

   -- Internal signal declarations
   SIGNAL CacheSel      : std_logic;
   SIGNAL Data_out0     : LC3B_OWORD;
   SIGNAL Data_out1     : LC3B_OWORD;
   SIGNAL Dirty_out0    : std_logic;
   SIGNAL Dirty_out1    : std_logic;
   SIGNAL LRU_out       : std_logic;
   SIGNAL RWactiveHIT   : std_logic;
   SIGNAL Tag_out0      : lc3b_c_tag;
   SIGNAL Tag_out1      : lc3b_c_tag;
   SIGNAL Valid_out0    : std_logic;
   SIGNAL Valid_out1    : std_logic;
   SIGNAL WRbackADDR    : LC3b_word;
   SIGNAL clk_delayed   : std_logic;
   SIGNAL eq_v0         : std_logic;
   SIGNAL eq_v1         : std_logic;
   SIGNAL isEqual0      : std_logic;
   SIGNAL isEqual1      : std_logic;
   SIGNAL offset        : lc3b_c_offset;
   SIGNAL offset3_1     : lc3b_8mux_sel;
   SIGNAL set_index     : lc3b_c_index;
   SIGNAL tag           : lc3b_c_tag;
   SIGNAL tagMUXout     : lc3b_c_tag;
   SIGNAL tag_delayed   : lc3b_c_tag;
   SIGNAL way0_write    : std_logic;
   SIGNAL way1_write    : std_logic;
   SIGNAL wayDin        : LC3b_oword;
   SIGNAL word0         : LC3B_WORD;
   SIGNAL word1         : LC3B_WORD;
   SIGNAL word2         : LC3B_WORD;
   SIGNAL word3         : LC3B_WORD;
   SIGNAL word4         : LC3B_WORD;
   SIGNAL word5         : LC3B_WORD;
   SIGNAL word6         : LC3B_WORD;
   SIGNAL word7         : LC3B_WORD;
   SIGNAL wordwrite_out : lc3b_oword;

   -- Implicit buffer signal declarations
   SIGNAL ACTIVE_internal    : std_logic;
   SIGNAL CACHE_HIT_internal : std_logic;
   SIGNAL MRESP_H_internal   : std_logic;
   SIGNAL PMDATAOUT_internal : LC3B_OWORD;
   SIGNAL WRITING_internal   : std_logic;


   -- Component Declarations
   COMPONENT ADDR_split
   PORT (
      ADDRESS   : IN     LC3b_word ;
      offset    : OUT    lc3b_c_offset ;
      offset3_1 : OUT    lc3b_8mux_sel ;
      set_index : OUT    lc3b_c_index ;
      tag       : OUT    lc3b_c_tag 
   );
   END COMPONENT;
   COMPONENT AND2
   PORT (
      A : IN     std_logic ;
      B : IN     std_logic ;
      C : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT AND3
   PORT (
      A : IN     std_logic ;
      B : IN     std_logic ;
      C : IN     std_logic ;
      D : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT ANDINV2
   PORT (
      A : IN     std_logic ;
      B : IN     std_logic ;
      C : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT BitArray_clked
   PORT (
      clk       : IN     std_logic ;
      Reset_L   : IN     std_logic ;
      DataWrite : IN     std_logic ;
      Index     : IN     LC3B_C_INDEX ;
      DataIn    : IN     std_logic ;
      DataOut   : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT MUX2
   PORT (
      A   : IN     std_logic ;
      B   : IN     std_logic ;
      Sel : IN     std_logic ;
      F   : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT NAND2
   PORT (
      A : IN     std_logic ;
      B : IN     std_logic ;
      C : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT NAND3
   PORT (
      A : IN     std_logic ;
      B : IN     std_logic ;
      C : IN     std_logic ;
      D : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT OR2
   PORT (
      A : IN     std_logic ;
      B : IN     std_logic ;
      C : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT OWordMux2
   PORT (
      A   : IN     LC3b_oword ;
      B   : IN     LC3b_oword ;
      Sel : IN     std_logic ;
      F   : OUT    LC3b_oword 
   );
   END COMPONENT;
   COMPONENT OWord_split
   PORT (
      PMDATAOUT : IN     LC3B_OWORD;
      word0     : OUT    LC3B_WORD;
      word1     : OUT    LC3B_WORD;
      word2     : OUT    LC3B_WORD;
      word3     : OUT    LC3B_WORD;
      word4     : OUT    LC3B_WORD;
      word5     : OUT    LC3B_WORD;
      word6     : OUT    LC3B_WORD;
      word7     : OUT    LC3B_WORD
   );
   END COMPONENT;
   COMPONENT Tag_Compare
   PORT (
      TagA    : IN     lc3b_c_tag;
      TagB    : IN     lc3b_c_tag;
      isEqual : OUT    std_logic
   );
   END COMPONENT;
   COMPONENT Way
   PORT (
      DataIn    : IN     LC3B_OWORD ;
      RESET_L   : IN     std_logic ;
      set_dirty : IN     std_logic ;
      set_index : IN     lc3b_c_index ;
      tag       : IN     lc3b_c_tag ;
      way_write : IN     std_logic ;
      Data_out  : OUT    LC3B_OWORD ;
      Dirty_out : OUT    std_logic ;
      Tag_out   : OUT    lc3b_c_tag ;
      Valid_out : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT WordMux2
   PORT (
      A   : IN     LC3b_word ;
      B   : IN     LC3b_word ;
      Sel : IN     std_logic ;
      F   : OUT    LC3b_word 
   );
   END COMPONENT;
   COMPONENT WordMux8
   PORT (
      A     : IN     lc3b_word ;
      B     : IN     lc3b_word ;
      C     : IN     lc3b_word ;
      D     : IN     lc3b_word ;
      E     : IN     lc3b_word ;
      F     : IN     lc3b_word ;
      G     : IN     lc3b_word ;
      H     : IN     lc3b_word ;
      Sel   : IN     lc3b_8mux_sel ;
      F_out : OUT    lc3b_word 
   );
   END COMPONENT;
   COMPONENT WordWrite
   PORT (
      DATAOUT       : IN     LC3b_word ;
      MWRITEH_L     : IN     std_logic ;
      MWRITEL_L     : IN     std_logic ;
      PMDATAIN      : IN     LC3B_OWORD ;
      offset3_1     : IN     lc3b_8mux_sel ;
      wordwrite_out : OUT    lc3b_oword 
   );
   END COMPONENT;
   COMPONENT bit_join
   PORT (
      set_index  : IN     lc3b_c_index ;
      tagMUXout  : IN     lc3b_c_tag ;
      WRbackADDR : OUT    LC3b_word 
   );
   END COMPONENT;
   COMPONENT clk_delay
   PORT (
      clk         : IN     std_logic ;
      clk_delayed : OUT    std_logic 
   );
   END COMPONENT;
   COMPONENT tagDelay20ns
   PORT (
      tag         : IN     lc3b_c_tag ;
      tag_delayed : OUT    lc3b_c_tag 
   );
   END COMPONENT;
   COMPONENT tagMUX
   PORT (
      A   : IN     lc3b_c_tag ;
      B   : IN     lc3b_c_tag ;
      Sel : IN     std_logic ;
      F   : OUT    lc3b_c_tag 
   );
   END COMPONENT;

   -- Optional embedded configurations
   -- pragma synthesis_off
   FOR ALL : ADDR_split USE ENTITY ece411.ADDR_split;
   FOR ALL : AND2 USE ENTITY ece411.AND2;
   FOR ALL : AND3 USE ENTITY ece411.AND3;
   FOR ALL : ANDINV2 USE ENTITY ece411.ANDINV2;
   FOR ALL : BitArray_clked USE ENTITY ece411.BitArray_clked;
   FOR ALL : MUX2 USE ENTITY ece411.MUX2;
   FOR ALL : NAND2 USE ENTITY ece411.NAND2;
   FOR ALL : NAND3 USE ENTITY ece411.NAND3;
   FOR ALL : OR2 USE ENTITY ece411.OR2;
   FOR ALL : OWordMux2 USE ENTITY ece411.OWordMux2;
   FOR ALL : OWord_split USE ENTITY ece411.OWord_split;
   FOR ALL : Tag_Compare USE ENTITY ece411.Tag_Compare;
   FOR ALL : Way USE ENTITY ece411.Way;
   FOR ALL : WordMux2 USE ENTITY ece411.WordMux2;
   FOR ALL : WordMux8 USE ENTITY ece411.WordMux8;
   FOR ALL : WordWrite USE ENTITY ece411.WordWrite;
   FOR ALL : bit_join USE ENTITY ece411.bit_join;
   FOR ALL : clk_delay USE ENTITY ece411.clk_delay;
   FOR ALL : tagDelay20ns USE ENTITY ece411.tagDelay20ns;
   FOR ALL : tagMUX USE ENTITY ece411.tagMUX;
   -- pragma synthesis_on


BEGIN

   -- Instance port mappings.
   aADDR_split : ADDR_split
      PORT MAP (
         ADDRESS   => ADDRESS,
         offset    => offset,
         offset3_1 => offset3_1,
         set_index => set_index,
         tag       => tag
      );
   ANDeq_v0 : AND2
      PORT MAP (
         A => isEqual0,
         B => Valid_out0,
         C => eq_v0
      );
   ANDeq_v1 : AND2
      PORT MAP (
         A => isEqual1,
         B => Valid_out1,
         C => eq_v1
      );
   U_2 : AND2
      PORT MAP (
         A => CacheSel,
         B => CACHE_WRITE,
         C => way1_write
      );
   RW_HIT : AND3
      PORT MAP (
         A => MRESP_EN,
         B => CACHE_HIT_internal,
         C => ACTIVE_internal,
         D => RWactiveHIT
      );
   U_9 : ANDINV2
      PORT MAP (
         A => CACHE_WRITE,
         B => CacheSel,
         C => way0_write
      );
   LRU_ARRAY : BitArray_clked
      PORT MAP (
         clk       => clk_delayed,
         Reset_L   => RESET_L,
         DataWrite => MRESP_H_internal,
         Index     => set_index,
         DataIn    => eq_v0,
         DataOut   => LRU_out
      );
   CacheWRMUX : MUX2
      PORT MAP (
         A   => LRU_out,
         B   => eq_v1,
         Sel => CACHE_HIT_internal,
         F   => CacheSel
      );
   DIRTYMUX : MUX2
      PORT MAP (
         A   => Dirty_out0,
         B   => Dirty_out1,
         Sel => LRU_out,
         F   => DIRTY
      );
   U_8 : MUX2
      PORT MAP (
         A   => RWactiveHIT,
         B   => WRstate,
         Sel => WRITING_internal,
         F   => MRESP_H_internal
      );
   Wsig : NAND2
      PORT MAP (
         A => MWRITEL_L,
         B => MWRITEH_L,
         C => WRITING_internal
      );
   NOT_IDLE : NAND3
      PORT MAP (
         A => MREAD_L,
         B => MWRITEL_L,
         C => MWRITEH_L,
         D => ACTIVE_internal
      );
   HIT : OR2
      PORT MAP (
         A => eq_v0,
         B => eq_v1,
         C => CACHE_HIT_internal
      );
   wayDataMUX : OWordMux2
      PORT MAP (
         A   => PMDATAIN,
         B   => wordwrite_out,
         Sel => WRstate,
         F   => wayDin
      );
   wayMux : OWordMux2
      PORT MAP (
         A   => Data_out0,
         B   => Data_out1,
         Sel => eq_v1,
         F   => PMDATAOUT_internal
      );
   splitter : OWord_split
      PORT MAP (
         word0     => word0,
         word1     => word1,
         word2     => word2,
         word3     => word3,
         word4     => word4,
         word5     => word5,
         word6     => word6,
         word7     => word7,
         PMDATAOUT => PMDATAOUT_internal
      );
   tag_comp0 : Tag_Compare
      PORT MAP (
         TagA    => Tag_out0,
         TagB    => tag_delayed,
         isEqual => isEqual0
      );
   tag_comp1 : Tag_Compare
      PORT MAP (
         TagA    => Tag_out1,
         TagB    => tag_delayed,
         isEqual => isEqual1
      );
   Way0 : Way
      PORT MAP (
         DataIn    => wayDin,
         RESET_L   => RESET_L,
         set_dirty => set_dirty,
         set_index => set_index,
         tag       => tag,
         way_write => way0_write,
         Data_out  => Data_out0,
         Dirty_out => Dirty_out0,
         Tag_out   => Tag_out0,
         Valid_out => Valid_out0
      );
   Way1 : Way
      PORT MAP (
         DataIn    => wayDin,
         RESET_L   => RESET_L,
         set_dirty => set_dirty,
         set_index => set_index,
         tag       => tag,
         way_write => way1_write,
         Data_out  => Data_out1,
         Dirty_out => Dirty_out1,
         Tag_out   => Tag_out1,
         Valid_out => Valid_out1
      );
   PMADDRMUX : WordMux2
      PORT MAP (
         A   => ADDRESS,
         B   => WRbackADDR,
         Sel => PMADDRsel,
         F   => PMADDRESS
      );
   DinMUX : WordMux8
      PORT MAP (
         A     => word0,
         B     => word1,
         C     => word2,
         D     => word3,
         E     => word4,
         F     => word5,
         G     => word6,
         H     => word7,
         Sel   => offset3_1,
         F_out => DATAIN
      );
   aWordWrite : WordWrite
      PORT MAP (
         DATAOUT       => DATAOUT,
         MWRITEH_L     => MWRITEH_L,
         MWRITEL_L     => MWRITEL_L,
         PMDATAIN      => PMDATAOUT_internal,
         offset3_1     => offset3_1,
         wordwrite_out => wordwrite_out
      );
   PMADDRcalc : bit_join
      PORT MAP (
         set_index  => set_index,
         tagMUXout  => tagMUXout,
         WRbackADDR => WRbackADDR
      );
   delay6ns : clk_delay
      PORT MAP (
         clk         => clk,
         clk_delayed => clk_delayed
      );
   U_4 : tagDelay20ns
      PORT MAP (
         tag         => tag,
         tag_delayed => tag_delayed
      );
   atagMux : tagMUX
      PORT MAP (
         A   => Tag_out0,
         B   => Tag_out1,
         Sel => LRU_out,
         F   => tagMUXout
      );

   -- Implicit buffered output assignments
   ACTIVE    <= ACTIVE_internal;
   CACHE_HIT <= CACHE_HIT_internal;
   MRESP_H   <= MRESP_H_internal;
   PMDATAOUT <= PMDATAOUT_internal;
   WRITING   <= WRITING_internal;

END struct;
